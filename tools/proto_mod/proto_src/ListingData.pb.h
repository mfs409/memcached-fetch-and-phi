// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ListingData.proto

#ifndef PROTOBUF_ListingData_2eproto__INCLUDED
#define PROTOBUF_ListingData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "AiringType.pb.h"
#include "Rating.pb.h"
// @@protoc_insertion_point(includes)

namespace scheduler {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ListingData_2eproto();
void protobuf_AssignDesc_ListingData_2eproto();
void protobuf_ShutdownFile_ListingData_2eproto();

class ListingData;

// ===================================================================

class ListingData : public ::google::protobuf::Message {
 public:
  ListingData();
  virtual ~ListingData();
  
  ListingData(const ListingData& from);
  
  inline ListingData& operator=(const ListingData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListingData& default_instance();
  
  void Swap(ListingData* other);
  
  // implements Message ----------------------------------------------
  
  ListingData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListingData& from);
  void MergeFrom(const ListingData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .scheduler.AiringType airingType = 1;
  inline bool has_airingtype() const;
  inline void clear_airingtype();
  static const int kAiringTypeFieldNumber = 1;
  inline scheduler::AiringType airingtype() const;
  inline void set_airingtype(scheduler::AiringType value);
  
  // optional string audioType = 2;
  inline bool has_audiotype() const;
  inline void clear_audiotype();
  static const int kAudioTypeFieldNumber = 2;
  inline const ::std::string& audiotype() const;
  inline void set_audiotype(const ::std::string& value);
  inline void set_audiotype(const char* value);
  inline void set_audiotype(const char* value, size_t size);
  inline ::std::string* mutable_audiotype();
  inline ::std::string* release_audiotype();
  
  // optional string captionType = 3;
  inline bool has_captiontype() const;
  inline void clear_captiontype();
  static const int kCaptionTypeFieldNumber = 3;
  inline const ::std::string& captiontype() const;
  inline void set_captiontype(const ::std::string& value);
  inline void set_captiontype(const char* value);
  inline void set_captiontype(const char* value, size_t size);
  inline ::std::string* mutable_captiontype();
  inline ::std::string* release_captiontype();
  
  // optional .scheduler.Rating schedulerContentRating = 4;
  inline bool has_schedulercontentrating() const;
  inline void clear_schedulercontentrating();
  static const int kSchedulerContentRatingFieldNumber = 4;
  inline const ::scheduler::Rating& schedulercontentrating() const;
  inline ::scheduler::Rating* mutable_schedulercontentrating();
  inline ::scheduler::Rating* release_schedulercontentrating();
  
  // required bool isAdult = 5;
  inline bool has_isadult() const;
  inline void clear_isadult();
  static const int kIsAdultFieldNumber = 5;
  inline bool isadult() const;
  inline void set_isadult(bool value);
  
  // optional string hdLevel = 6;
  inline bool has_hdlevel() const;
  inline void clear_hdlevel();
  static const int kHdLevelFieldNumber = 6;
  inline const ::std::string& hdlevel() const;
  inline void set_hdlevel(const ::std::string& value);
  inline void set_hdlevel(const char* value);
  inline void set_hdlevel(const char* value, size_t size);
  inline ::std::string* mutable_hdlevel();
  inline ::std::string* release_hdlevel();
  
  // optional string seriesGuid = 7;
  inline bool has_seriesguid() const;
  inline void clear_seriesguid();
  static const int kSeriesGuidFieldNumber = 7;
  inline const ::std::string& seriesguid() const;
  inline void set_seriesguid(const ::std::string& value);
  inline void set_seriesguid(const char* value);
  inline void set_seriesguid(const char* value, size_t size);
  inline ::std::string* mutable_seriesguid();
  inline ::std::string* release_seriesguid();
  
  // optional string showingType = 8;
  inline bool has_showingtype() const;
  inline void clear_showingtype();
  static const int kShowingTypeFieldNumber = 8;
  inline const ::std::string& showingtype() const;
  inline void set_showingtype(const ::std::string& value);
  inline void set_showingtype(const char* value);
  inline void set_showingtype(const char* value, size_t size);
  inline ::std::string* mutable_showingtype();
  inline ::std::string* release_showingtype();
  
  // required bool isSAP = 9;
  inline bool has_issap() const;
  inline void clear_issap();
  static const int kIsSAPFieldNumber = 9;
  inline bool issap() const;
  inline void set_issap(bool value);
  
  // required bool isSubTitled = 10;
  inline bool has_issubtitled() const;
  inline void clear_issubtitled();
  static const int kIsSubTitledFieldNumber = 10;
  inline bool issubtitled() const;
  inline void set_issubtitled(bool value);
  
  // required bool isThreeD = 11;
  inline bool has_isthreed() const;
  inline void clear_isthreed();
  static const int kIsThreeDFieldNumber = 11;
  inline bool isthreed() const;
  inline void set_isthreed(bool value);
  
  // optional string programGuid = 12;
  inline bool has_programguid() const;
  inline void clear_programguid();
  static const int kProgramGuidFieldNumber = 12;
  inline const ::std::string& programguid() const;
  inline void set_programguid(const ::std::string& value);
  inline void set_programguid(const char* value);
  inline void set_programguid(const char* value, size_t size);
  inline ::std::string* mutable_programguid();
  inline ::std::string* release_programguid();
  
  // required int64 programStart = 13;
  inline bool has_programstart() const;
  inline void clear_programstart();
  static const int kProgramStartFieldNumber = 13;
  inline ::google::protobuf::int64 programstart() const;
  inline void set_programstart(::google::protobuf::int64 value);
  
  // required int64 programEnd = 14;
  inline bool has_programend() const;
  inline void clear_programend();
  static const int kProgramEndFieldNumber = 14;
  inline ::google::protobuf::int64 programend() const;
  inline void set_programend(::google::protobuf::int64 value);
  
  // optional string listingGuid = 15;
  inline bool has_listingguid() const;
  inline void clear_listingguid();
  static const int kListingGuidFieldNumber = 15;
  inline const ::std::string& listingguid() const;
  inline void set_listingguid(const ::std::string& value);
  inline void set_listingguid(const char* value);
  inline void set_listingguid(const char* value, size_t size);
  inline ::std::string* mutable_listingguid();
  inline ::std::string* release_listingguid();
  
  // optional int32 seasonNumber = 16;
  inline bool has_seasonnumber() const;
  inline void clear_seasonnumber();
  static const int kSeasonNumberFieldNumber = 16;
  inline ::google::protobuf::int32 seasonnumber() const;
  inline void set_seasonnumber(::google::protobuf::int32 value);
  
  // optional int32 episodeNumber = 17;
  inline bool has_episodenumber() const;
  inline void clear_episodenumber();
  static const int kEpisodeNumberFieldNumber = 17;
  inline ::google::protobuf::int32 episodenumber() const;
  inline void set_episodenumber(::google::protobuf::int32 value);
  
  // optional string episodeTitle = 18;
  inline bool has_episodetitle() const;
  inline void clear_episodetitle();
  static const int kEpisodeTitleFieldNumber = 18;
  inline const ::std::string& episodetitle() const;
  inline void set_episodetitle(const ::std::string& value);
  inline void set_episodetitle(const char* value);
  inline void set_episodetitle(const char* value, size_t size);
  inline ::std::string* mutable_episodetitle();
  inline ::std::string* release_episodetitle();
  
  // optional string strProgramType = 19;
  inline bool has_strprogramtype() const;
  inline void clear_strprogramtype();
  static const int kStrProgramTypeFieldNumber = 19;
  inline const ::std::string& strprogramtype() const;
  inline void set_strprogramtype(const ::std::string& value);
  inline void set_strprogramtype(const char* value);
  inline void set_strprogramtype(const char* value, size_t size);
  inline ::std::string* mutable_strprogramtype();
  inline ::std::string* release_strprogramtype();
  
  // @@protoc_insertion_point(class_scope:scheduler.ListingData)
 private:
  inline void set_has_airingtype();
  inline void clear_has_airingtype();
  inline void set_has_audiotype();
  inline void clear_has_audiotype();
  inline void set_has_captiontype();
  inline void clear_has_captiontype();
  inline void set_has_schedulercontentrating();
  inline void clear_has_schedulercontentrating();
  inline void set_has_isadult();
  inline void clear_has_isadult();
  inline void set_has_hdlevel();
  inline void clear_has_hdlevel();
  inline void set_has_seriesguid();
  inline void clear_has_seriesguid();
  inline void set_has_showingtype();
  inline void clear_has_showingtype();
  inline void set_has_issap();
  inline void clear_has_issap();
  inline void set_has_issubtitled();
  inline void clear_has_issubtitled();
  inline void set_has_isthreed();
  inline void clear_has_isthreed();
  inline void set_has_programguid();
  inline void clear_has_programguid();
  inline void set_has_programstart();
  inline void clear_has_programstart();
  inline void set_has_programend();
  inline void clear_has_programend();
  inline void set_has_listingguid();
  inline void clear_has_listingguid();
  inline void set_has_seasonnumber();
  inline void clear_has_seasonnumber();
  inline void set_has_episodenumber();
  inline void clear_has_episodenumber();
  inline void set_has_episodetitle();
  inline void clear_has_episodetitle();
  inline void set_has_strprogramtype();
  inline void clear_has_strprogramtype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* audiotype_;
  ::std::string* captiontype_;
  ::scheduler::Rating* schedulercontentrating_;
  ::std::string* hdlevel_;
  ::std::string* seriesguid_;
  int airingtype_;
  bool isadult_;
  bool issap_;
  bool issubtitled_;
  bool isthreed_;
  ::std::string* showingtype_;
  ::std::string* programguid_;
  ::google::protobuf::int64 programstart_;
  ::google::protobuf::int64 programend_;
  ::std::string* listingguid_;
  ::google::protobuf::int32 seasonnumber_;
  ::google::protobuf::int32 episodenumber_;
  ::std::string* episodetitle_;
  ::std::string* strprogramtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];
  
  friend void  protobuf_AddDesc_ListingData_2eproto();
  friend void protobuf_AssignDesc_ListingData_2eproto();
  friend void protobuf_ShutdownFile_ListingData_2eproto();
  
  void InitAsDefaultInstance();
  static ListingData* default_instance_;
};
// ===================================================================


// ===================================================================

// ListingData

// optional .scheduler.AiringType airingType = 1;
inline bool ListingData::has_airingtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListingData::set_has_airingtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListingData::clear_has_airingtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListingData::clear_airingtype() {
  airingtype_ = 0;
  clear_has_airingtype();
}
inline scheduler::AiringType ListingData::airingtype() const {
  return static_cast< scheduler::AiringType >(airingtype_);
}
inline void ListingData::set_airingtype(scheduler::AiringType value) {
  GOOGLE_DCHECK(scheduler::AiringType_IsValid(value));
  set_has_airingtype();
  airingtype_ = value;
}

// optional string audioType = 2;
inline bool ListingData::has_audiotype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListingData::set_has_audiotype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListingData::clear_has_audiotype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListingData::clear_audiotype() {
  if (audiotype_ != &::google::protobuf::internal::kEmptyString) {
    audiotype_->clear();
  }
  clear_has_audiotype();
}
inline const ::std::string& ListingData::audiotype() const {
  return *audiotype_;
}
inline void ListingData::set_audiotype(const ::std::string& value) {
  set_has_audiotype();
  if (audiotype_ == &::google::protobuf::internal::kEmptyString) {
    audiotype_ = new ::std::string;
  }
  audiotype_->assign(value);
}
inline void ListingData::set_audiotype(const char* value) {
  set_has_audiotype();
  if (audiotype_ == &::google::protobuf::internal::kEmptyString) {
    audiotype_ = new ::std::string;
  }
  audiotype_->assign(value);
}
inline void ListingData::set_audiotype(const char* value, size_t size) {
  set_has_audiotype();
  if (audiotype_ == &::google::protobuf::internal::kEmptyString) {
    audiotype_ = new ::std::string;
  }
  audiotype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListingData::mutable_audiotype() {
  set_has_audiotype();
  if (audiotype_ == &::google::protobuf::internal::kEmptyString) {
    audiotype_ = new ::std::string;
  }
  return audiotype_;
}
inline ::std::string* ListingData::release_audiotype() {
  clear_has_audiotype();
  if (audiotype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = audiotype_;
    audiotype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string captionType = 3;
inline bool ListingData::has_captiontype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListingData::set_has_captiontype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListingData::clear_has_captiontype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListingData::clear_captiontype() {
  if (captiontype_ != &::google::protobuf::internal::kEmptyString) {
    captiontype_->clear();
  }
  clear_has_captiontype();
}
inline const ::std::string& ListingData::captiontype() const {
  return *captiontype_;
}
inline void ListingData::set_captiontype(const ::std::string& value) {
  set_has_captiontype();
  if (captiontype_ == &::google::protobuf::internal::kEmptyString) {
    captiontype_ = new ::std::string;
  }
  captiontype_->assign(value);
}
inline void ListingData::set_captiontype(const char* value) {
  set_has_captiontype();
  if (captiontype_ == &::google::protobuf::internal::kEmptyString) {
    captiontype_ = new ::std::string;
  }
  captiontype_->assign(value);
}
inline void ListingData::set_captiontype(const char* value, size_t size) {
  set_has_captiontype();
  if (captiontype_ == &::google::protobuf::internal::kEmptyString) {
    captiontype_ = new ::std::string;
  }
  captiontype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListingData::mutable_captiontype() {
  set_has_captiontype();
  if (captiontype_ == &::google::protobuf::internal::kEmptyString) {
    captiontype_ = new ::std::string;
  }
  return captiontype_;
}
inline ::std::string* ListingData::release_captiontype() {
  clear_has_captiontype();
  if (captiontype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = captiontype_;
    captiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .scheduler.Rating schedulerContentRating = 4;
inline bool ListingData::has_schedulercontentrating() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListingData::set_has_schedulercontentrating() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListingData::clear_has_schedulercontentrating() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListingData::clear_schedulercontentrating() {
  if (schedulercontentrating_ != NULL) schedulercontentrating_->::scheduler::Rating::Clear();
  clear_has_schedulercontentrating();
}
inline const ::scheduler::Rating& ListingData::schedulercontentrating() const {
  return schedulercontentrating_ != NULL ? *schedulercontentrating_ : *default_instance_->schedulercontentrating_;
}
inline ::scheduler::Rating* ListingData::mutable_schedulercontentrating() {
  set_has_schedulercontentrating();
  if (schedulercontentrating_ == NULL) schedulercontentrating_ = new ::scheduler::Rating;
  return schedulercontentrating_;
}
inline ::scheduler::Rating* ListingData::release_schedulercontentrating() {
  clear_has_schedulercontentrating();
  ::scheduler::Rating* temp = schedulercontentrating_;
  schedulercontentrating_ = NULL;
  return temp;
}

// required bool isAdult = 5;
inline bool ListingData::has_isadult() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ListingData::set_has_isadult() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ListingData::clear_has_isadult() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ListingData::clear_isadult() {
  isadult_ = false;
  clear_has_isadult();
}
inline bool ListingData::isadult() const {
  return isadult_;
}
inline void ListingData::set_isadult(bool value) {
  set_has_isadult();
  isadult_ = value;
}

// optional string hdLevel = 6;
inline bool ListingData::has_hdlevel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ListingData::set_has_hdlevel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ListingData::clear_has_hdlevel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ListingData::clear_hdlevel() {
  if (hdlevel_ != &::google::protobuf::internal::kEmptyString) {
    hdlevel_->clear();
  }
  clear_has_hdlevel();
}
inline const ::std::string& ListingData::hdlevel() const {
  return *hdlevel_;
}
inline void ListingData::set_hdlevel(const ::std::string& value) {
  set_has_hdlevel();
  if (hdlevel_ == &::google::protobuf::internal::kEmptyString) {
    hdlevel_ = new ::std::string;
  }
  hdlevel_->assign(value);
}
inline void ListingData::set_hdlevel(const char* value) {
  set_has_hdlevel();
  if (hdlevel_ == &::google::protobuf::internal::kEmptyString) {
    hdlevel_ = new ::std::string;
  }
  hdlevel_->assign(value);
}
inline void ListingData::set_hdlevel(const char* value, size_t size) {
  set_has_hdlevel();
  if (hdlevel_ == &::google::protobuf::internal::kEmptyString) {
    hdlevel_ = new ::std::string;
  }
  hdlevel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListingData::mutable_hdlevel() {
  set_has_hdlevel();
  if (hdlevel_ == &::google::protobuf::internal::kEmptyString) {
    hdlevel_ = new ::std::string;
  }
  return hdlevel_;
}
inline ::std::string* ListingData::release_hdlevel() {
  clear_has_hdlevel();
  if (hdlevel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hdlevel_;
    hdlevel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string seriesGuid = 7;
inline bool ListingData::has_seriesguid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ListingData::set_has_seriesguid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ListingData::clear_has_seriesguid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ListingData::clear_seriesguid() {
  if (seriesguid_ != &::google::protobuf::internal::kEmptyString) {
    seriesguid_->clear();
  }
  clear_has_seriesguid();
}
inline const ::std::string& ListingData::seriesguid() const {
  return *seriesguid_;
}
inline void ListingData::set_seriesguid(const ::std::string& value) {
  set_has_seriesguid();
  if (seriesguid_ == &::google::protobuf::internal::kEmptyString) {
    seriesguid_ = new ::std::string;
  }
  seriesguid_->assign(value);
}
inline void ListingData::set_seriesguid(const char* value) {
  set_has_seriesguid();
  if (seriesguid_ == &::google::protobuf::internal::kEmptyString) {
    seriesguid_ = new ::std::string;
  }
  seriesguid_->assign(value);
}
inline void ListingData::set_seriesguid(const char* value, size_t size) {
  set_has_seriesguid();
  if (seriesguid_ == &::google::protobuf::internal::kEmptyString) {
    seriesguid_ = new ::std::string;
  }
  seriesguid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListingData::mutable_seriesguid() {
  set_has_seriesguid();
  if (seriesguid_ == &::google::protobuf::internal::kEmptyString) {
    seriesguid_ = new ::std::string;
  }
  return seriesguid_;
}
inline ::std::string* ListingData::release_seriesguid() {
  clear_has_seriesguid();
  if (seriesguid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seriesguid_;
    seriesguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string showingType = 8;
inline bool ListingData::has_showingtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ListingData::set_has_showingtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ListingData::clear_has_showingtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ListingData::clear_showingtype() {
  if (showingtype_ != &::google::protobuf::internal::kEmptyString) {
    showingtype_->clear();
  }
  clear_has_showingtype();
}
inline const ::std::string& ListingData::showingtype() const {
  return *showingtype_;
}
inline void ListingData::set_showingtype(const ::std::string& value) {
  set_has_showingtype();
  if (showingtype_ == &::google::protobuf::internal::kEmptyString) {
    showingtype_ = new ::std::string;
  }
  showingtype_->assign(value);
}
inline void ListingData::set_showingtype(const char* value) {
  set_has_showingtype();
  if (showingtype_ == &::google::protobuf::internal::kEmptyString) {
    showingtype_ = new ::std::string;
  }
  showingtype_->assign(value);
}
inline void ListingData::set_showingtype(const char* value, size_t size) {
  set_has_showingtype();
  if (showingtype_ == &::google::protobuf::internal::kEmptyString) {
    showingtype_ = new ::std::string;
  }
  showingtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListingData::mutable_showingtype() {
  set_has_showingtype();
  if (showingtype_ == &::google::protobuf::internal::kEmptyString) {
    showingtype_ = new ::std::string;
  }
  return showingtype_;
}
inline ::std::string* ListingData::release_showingtype() {
  clear_has_showingtype();
  if (showingtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = showingtype_;
    showingtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool isSAP = 9;
inline bool ListingData::has_issap() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ListingData::set_has_issap() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ListingData::clear_has_issap() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ListingData::clear_issap() {
  issap_ = false;
  clear_has_issap();
}
inline bool ListingData::issap() const {
  return issap_;
}
inline void ListingData::set_issap(bool value) {
  set_has_issap();
  issap_ = value;
}

// required bool isSubTitled = 10;
inline bool ListingData::has_issubtitled() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ListingData::set_has_issubtitled() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ListingData::clear_has_issubtitled() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ListingData::clear_issubtitled() {
  issubtitled_ = false;
  clear_has_issubtitled();
}
inline bool ListingData::issubtitled() const {
  return issubtitled_;
}
inline void ListingData::set_issubtitled(bool value) {
  set_has_issubtitled();
  issubtitled_ = value;
}

// required bool isThreeD = 11;
inline bool ListingData::has_isthreed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ListingData::set_has_isthreed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ListingData::clear_has_isthreed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ListingData::clear_isthreed() {
  isthreed_ = false;
  clear_has_isthreed();
}
inline bool ListingData::isthreed() const {
  return isthreed_;
}
inline void ListingData::set_isthreed(bool value) {
  set_has_isthreed();
  isthreed_ = value;
}

// optional string programGuid = 12;
inline bool ListingData::has_programguid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ListingData::set_has_programguid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ListingData::clear_has_programguid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ListingData::clear_programguid() {
  if (programguid_ != &::google::protobuf::internal::kEmptyString) {
    programguid_->clear();
  }
  clear_has_programguid();
}
inline const ::std::string& ListingData::programguid() const {
  return *programguid_;
}
inline void ListingData::set_programguid(const ::std::string& value) {
  set_has_programguid();
  if (programguid_ == &::google::protobuf::internal::kEmptyString) {
    programguid_ = new ::std::string;
  }
  programguid_->assign(value);
}
inline void ListingData::set_programguid(const char* value) {
  set_has_programguid();
  if (programguid_ == &::google::protobuf::internal::kEmptyString) {
    programguid_ = new ::std::string;
  }
  programguid_->assign(value);
}
inline void ListingData::set_programguid(const char* value, size_t size) {
  set_has_programguid();
  if (programguid_ == &::google::protobuf::internal::kEmptyString) {
    programguid_ = new ::std::string;
  }
  programguid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListingData::mutable_programguid() {
  set_has_programguid();
  if (programguid_ == &::google::protobuf::internal::kEmptyString) {
    programguid_ = new ::std::string;
  }
  return programguid_;
}
inline ::std::string* ListingData::release_programguid() {
  clear_has_programguid();
  if (programguid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = programguid_;
    programguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 programStart = 13;
inline bool ListingData::has_programstart() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ListingData::set_has_programstart() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ListingData::clear_has_programstart() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ListingData::clear_programstart() {
  programstart_ = GOOGLE_LONGLONG(0);
  clear_has_programstart();
}
inline ::google::protobuf::int64 ListingData::programstart() const {
  return programstart_;
}
inline void ListingData::set_programstart(::google::protobuf::int64 value) {
  set_has_programstart();
  programstart_ = value;
}

// required int64 programEnd = 14;
inline bool ListingData::has_programend() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ListingData::set_has_programend() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ListingData::clear_has_programend() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ListingData::clear_programend() {
  programend_ = GOOGLE_LONGLONG(0);
  clear_has_programend();
}
inline ::google::protobuf::int64 ListingData::programend() const {
  return programend_;
}
inline void ListingData::set_programend(::google::protobuf::int64 value) {
  set_has_programend();
  programend_ = value;
}

// optional string listingGuid = 15;
inline bool ListingData::has_listingguid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ListingData::set_has_listingguid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ListingData::clear_has_listingguid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ListingData::clear_listingguid() {
  if (listingguid_ != &::google::protobuf::internal::kEmptyString) {
    listingguid_->clear();
  }
  clear_has_listingguid();
}
inline const ::std::string& ListingData::listingguid() const {
  return *listingguid_;
}
inline void ListingData::set_listingguid(const ::std::string& value) {
  set_has_listingguid();
  if (listingguid_ == &::google::protobuf::internal::kEmptyString) {
    listingguid_ = new ::std::string;
  }
  listingguid_->assign(value);
}
inline void ListingData::set_listingguid(const char* value) {
  set_has_listingguid();
  if (listingguid_ == &::google::protobuf::internal::kEmptyString) {
    listingguid_ = new ::std::string;
  }
  listingguid_->assign(value);
}
inline void ListingData::set_listingguid(const char* value, size_t size) {
  set_has_listingguid();
  if (listingguid_ == &::google::protobuf::internal::kEmptyString) {
    listingguid_ = new ::std::string;
  }
  listingguid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListingData::mutable_listingguid() {
  set_has_listingguid();
  if (listingguid_ == &::google::protobuf::internal::kEmptyString) {
    listingguid_ = new ::std::string;
  }
  return listingguid_;
}
inline ::std::string* ListingData::release_listingguid() {
  clear_has_listingguid();
  if (listingguid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = listingguid_;
    listingguid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 seasonNumber = 16;
inline bool ListingData::has_seasonnumber() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ListingData::set_has_seasonnumber() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ListingData::clear_has_seasonnumber() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ListingData::clear_seasonnumber() {
  seasonnumber_ = 0;
  clear_has_seasonnumber();
}
inline ::google::protobuf::int32 ListingData::seasonnumber() const {
  return seasonnumber_;
}
inline void ListingData::set_seasonnumber(::google::protobuf::int32 value) {
  set_has_seasonnumber();
  seasonnumber_ = value;
}

// optional int32 episodeNumber = 17;
inline bool ListingData::has_episodenumber() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ListingData::set_has_episodenumber() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ListingData::clear_has_episodenumber() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ListingData::clear_episodenumber() {
  episodenumber_ = 0;
  clear_has_episodenumber();
}
inline ::google::protobuf::int32 ListingData::episodenumber() const {
  return episodenumber_;
}
inline void ListingData::set_episodenumber(::google::protobuf::int32 value) {
  set_has_episodenumber();
  episodenumber_ = value;
}

// optional string episodeTitle = 18;
inline bool ListingData::has_episodetitle() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ListingData::set_has_episodetitle() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ListingData::clear_has_episodetitle() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ListingData::clear_episodetitle() {
  if (episodetitle_ != &::google::protobuf::internal::kEmptyString) {
    episodetitle_->clear();
  }
  clear_has_episodetitle();
}
inline const ::std::string& ListingData::episodetitle() const {
  return *episodetitle_;
}
inline void ListingData::set_episodetitle(const ::std::string& value) {
  set_has_episodetitle();
  if (episodetitle_ == &::google::protobuf::internal::kEmptyString) {
    episodetitle_ = new ::std::string;
  }
  episodetitle_->assign(value);
}
inline void ListingData::set_episodetitle(const char* value) {
  set_has_episodetitle();
  if (episodetitle_ == &::google::protobuf::internal::kEmptyString) {
    episodetitle_ = new ::std::string;
  }
  episodetitle_->assign(value);
}
inline void ListingData::set_episodetitle(const char* value, size_t size) {
  set_has_episodetitle();
  if (episodetitle_ == &::google::protobuf::internal::kEmptyString) {
    episodetitle_ = new ::std::string;
  }
  episodetitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListingData::mutable_episodetitle() {
  set_has_episodetitle();
  if (episodetitle_ == &::google::protobuf::internal::kEmptyString) {
    episodetitle_ = new ::std::string;
  }
  return episodetitle_;
}
inline ::std::string* ListingData::release_episodetitle() {
  clear_has_episodetitle();
  if (episodetitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = episodetitle_;
    episodetitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strProgramType = 19;
inline bool ListingData::has_strprogramtype() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ListingData::set_has_strprogramtype() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ListingData::clear_has_strprogramtype() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ListingData::clear_strprogramtype() {
  if (strprogramtype_ != &::google::protobuf::internal::kEmptyString) {
    strprogramtype_->clear();
  }
  clear_has_strprogramtype();
}
inline const ::std::string& ListingData::strprogramtype() const {
  return *strprogramtype_;
}
inline void ListingData::set_strprogramtype(const ::std::string& value) {
  set_has_strprogramtype();
  if (strprogramtype_ == &::google::protobuf::internal::kEmptyString) {
    strprogramtype_ = new ::std::string;
  }
  strprogramtype_->assign(value);
}
inline void ListingData::set_strprogramtype(const char* value) {
  set_has_strprogramtype();
  if (strprogramtype_ == &::google::protobuf::internal::kEmptyString) {
    strprogramtype_ = new ::std::string;
  }
  strprogramtype_->assign(value);
}
inline void ListingData::set_strprogramtype(const char* value, size_t size) {
  set_has_strprogramtype();
  if (strprogramtype_ == &::google::protobuf::internal::kEmptyString) {
    strprogramtype_ = new ::std::string;
  }
  strprogramtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListingData::mutable_strprogramtype() {
  set_has_strprogramtype();
  if (strprogramtype_ == &::google::protobuf::internal::kEmptyString) {
    strprogramtype_ = new ::std::string;
  }
  return strprogramtype_;
}
inline ::std::string* ListingData::release_strprogramtype() {
  clear_has_strprogramtype();
  if (strprogramtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strprogramtype_;
    strprogramtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace scheduler

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ListingData_2eproto__INCLUDED
